# Limiting
  - 限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。

## 限流方法
  - **计数器**
    控制单位时间内的请求数量。直接计数，简单暴力，举个例子：
    比如限流设定为1小时内10次，那么每次收到请求就计数加一，并判断这一小时内计数是否大于上限10，没超过上限就返回成功，否则返回失败。

    这个算法的缺点就是在时间临界点会有较大瞬间流量。
  > 
  - **滑动窗口**
    滑动窗口是对计数器方式的改进，增加一个时间粒度的度量单位，把一分钟分成若干等分(6 份，每份 10 秒)，在每一份上设置独立计数器，在 00:00-00:09 之间发生请求计数器累加 1。当等分数量越大限流统计就越详细。我们将时间间隔均匀分隔，比如将一分钟分为6个10秒，每一个10秒内单独计数，总的数量限制为这6个10秒的总和，我们把这6个10秒成为“窗口”。那么每过10秒，窗口往前滑动一步，数量限制变为新的6个10秒的总和.
    >
    但是滑动窗口仍然有缺陷，为了保证匀速，我们要划分尽可能多的格子，而格子越多，每一个格子能够接收的请求数就越少，这样就限制了系统瞬间处理能力。

  >
  - **Leaky Bucket 漏桶**
    规定固定容量的桶，有水进入，有水流出。对于流进的水我们无法估计进来的数量、速度，对于流出的水我们可以控制速度。漏桶算法其实也很简单，假设我们有一个固定容量的桶，流速（系统处理能力）固定，如果一段时间水龙头水流太大，水就溢出了（请求被抛弃了）。
    用编程的语言来说，每次请求进来都放入一个先进先出的队列中，队列满了，则直接返回失败。另外有一个线程池固定间隔不断地从这个队列中拉取请求。
    > 
    消息队列、jdk的线程池，都有类似的设计。
    > 
  - **Token Bucket 令牌桶**
    规定固定容量的桶， token 以固定速度往桶内填充， 当桶满时 token 不会被继续放入， 每过来一个请求把 token 从桶中移除， 如果桶中没有 token 不能请求。首先，我们有一个固定容量的桶，桶里存放着令牌（token）。桶一开始是空的，token以一个固定的速率往桶里填充，直到达到桶的容量，多余的令牌将会被丢弃。每当一个请求过来时，就会尝试从桶里移除一个令牌，如果没有令牌的话，请求无法通过。RateLimiter是Guava中基于令牌桶实现的一个限流工具，使用非常简单。
    ***漏桶和令牌桶算法的区别*** 
    - 漏桶的特点是消费能力固定，当请求量超出消费能力时，提供一定的冗余能力，把请求缓存下来匀速消费。优点是对下游保护更好。
    
    - 令牌桶遇到激增流量会更从容，只要存在令牌，则可以一并消费掉。适合有突发特征的流量，如秒杀场景。
   

  
  ---
  ## 参考资料
  - [一文读懂限流算法及方案介绍](https://www.toutiao.com/article/7205013907977650692/?app=news_article&timestamp=1677564251&use_new_style=1&req_id=202302281404117443159DA6B61E0079FC&group_id=7205013907977650692&share_token=3B78123E-1776-4456-9601-BCB35E4B5F8C&tt_from=weixin&utm_source=weixin&utm_medium=toutiao_ios&utm_campaign=client_share&wxshare_count=1&source=m_redirect)
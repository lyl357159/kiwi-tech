# ThreadPool

## Java自带的线程池
   - FixedThreadPool（固定大小线程池）：该线程池具有固定数量的线程，一旦有一个任务提交，就会立即执行。当线程池中的所有线程都在工作时，新任务将在队列中等待。
   - CachedThreadPool（缓存线程池）：该线程池大小不固定，会根据任务的数量自动调整线程池的大小，当线程池中的线程空闲超过60秒时，这些线程将被终止并从池中删除。
   - SingleThreadPool（单线程池）：该线程池中只有一个线程，所有任务按照指定的顺序执行，如果该线程意外终止，会创建一个新的线程继续执行后续任务。
   - ScheduledThreadPool（定时线程池）：该线程池可以定时或延迟执行任务，可以设置任务的执行时间和周期。
   - WorkStealingPool（工作窃取线程池）：该线程池使用多个队列，每个队列对应一个线程，当某个线程的队列为空时，它会从其他线程的队列中“窃取”一个任务来执行，这种方式可以减少线程间的竞争，提高执行效率。
   > ThreadPoolExecutor：创建一个自定义的线程池，可以指定核心线程数，最大线程数，空闲线程存活时间，任务队列，拒绝策略等参数。这种线程池可以根据具体的业务场景和需求来调整，避免了使用Executors创建的线程池可能带来的资源耗尽的风险。

## 拒绝策略(RejectedExecutionHandler)
   - 内置的拒绝策略
     - **AbortPolicy** 抛出异常，中止任务。抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行
     - **CallerRunsPolicy** - 使用调用线程执行任务。当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大
     - **DiscardPolic**y** - 直接丢弃，其他啥都没有
     - **DiscardOldestPolicy** - 丢弃队列最老任务，添加新任务。当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务

## CPU密集型 和 I/O密集型
  - **CPU密集型**
    - CPU密集型，也叫计算密集型，一般是指服务器的硬盘、内存硬件性能相对CPU好很多，或者使用率低很多。系统运行CPU读写I/O(硬盘/内存)时可以在很短的时间内完成，几乎没有阻塞（等待I/O的实时间）时间，而CPU一直有大量运算要处理，因此CPU负载长期过高。
    - CPU密集几乎无I/O阻塞，CPU一直会全速运行。如果是单核情况下，开多线程是没有意义的，说白了就是一个CPU来回切着运行而已，徒增线程切换的资源消耗，卵用没有。可见，CPU密集任务只有在多核CPU上、开多线程才可能提速。
    - CPU使用率较高时（如我们训练算法模型、搞训练集），通常线程数只需要设置为CPU核心数的线程个数就可以了。单CPU对应单线程效率最高。
    - 一般其计算公式可遵循：**CPU密集型核心线程数 = CPU核数**。
 - **I/O密集型**
   - I/O密集型相反，一般是指服务器CPU的性能相对硬盘、内存硬件好很多，或者使用率低很多。系统运行多是CPU在等I/O (硬盘/内存) 的读写操作，此类情景下CPU负载并不高。
   - I/O密集型的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而程序的逻辑做得并不好，没有充分利用CPU能力，导致线程空余时间很多。通常我们会开CPU核心数数倍的线程，在线程进行 I/O 操作 CPU 空闲时，启用其他线程继续使用 CPU，以提高 CPU 的使用率，充分利用CPU资源。
   - 一般其计算公式可遵循：**I/O密集型核心线程数 = CPU核数 / （1-阻塞系数）**。
   - 阻塞系数在在0到1范围内。一般为0.8~0.9之间，也可以取0.8或者0.9。对于双核CPU来说，它比较理想的线程数就是20，当然这都不是绝对的，需要根据实际情况以及实际业务来调整。

---
## 参考资料
  - [怎么理解 CPU密集型 和 I/O密集型？](https://bbs.huaweicloud.com/blogs/344722)


---
- [返回首页](../../../README.md)
# JMM

---
## JMM的三大特性
- **原子性**: ***多线程切换带来了原子性问题***。
  一个或多个操作，要么全部执行，要么全部不执行（执行的过程中是不会被任何因素打断的)。
  **解决方案**：在 Java 中，可以借助synchronized 、各种 Lock 以及各种原子类实现原子性。synchronized和各种 Lock可以保证程序最终正确性，是的程序不受原子性问题的影响。原子操作类底层使用CAS机制，能保证操作真正的原子性。
>
- **有序性**: ***编译优化带来了有序性问题***。
  有序性可以总结为：在本线程内观察，所有的操作都是有序的；而在一个线程内观察另一个线程，所有操作都是无序的。前半句指 as-if-serial 语义：线程内似表现为串行，后半句是指：“指令重排序现象”和“工作内存与主内存同步延迟现象”。处理器为了提高程序的运行效率，提高并行效率，可能会对代码进行优化。编译器认为，重排序后的代码执行效率更优。这样一来，代码的执行顺序就未必是编写代码时候的顺序了，在多线程的情况下就可能会出错。
  **解决方案**：在Java 中 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行进入。

>
- **可见性**: ***多级CPU缓存带来了可见性问题***。
  只要有一个线程对共享变量的值做了修改，其他线程都将马上收到通知，立即获得最新值。
  **解决方案**: 在 Java 中，可以借助synchronized 、volatile 以及各种 Lock 实现可见性。用volatile关键字可以保证变量的写入操作对其他线程可见，使用synchronized关键字可以保证多个线程之间的操作是有序的，同时也可以保证锁的释放对其他线程的可见性。此外，Java中还提供了一些并发工具类，比如CountDownLatch、CyclicBarrier等，这些工具类也可以保证线程之间的可见性。

---
## Happens-before原则
   A happens-before B就是A先行发生于B（这种说法不是很准确），定义为hb(A, B)。在Java内存模型中，happens-before的意思是前一个操作的结果可以被后续操作获取。
   - **程序次序规则**：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。
   - **管程锁定规则**：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）
   - **volatile变量规则**：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。
   - **线程启动规则**：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。
   - **线程终止规则**：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。也称线程join()规则。
   - **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。
   - **传递性规则**：这个简单的，就是happens-before原则具有传递性，即hb(A, B) ， hb(B, C)，那么hb(A, C)。
   - **对象终结规则**：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。

---
## JMM中的八种操作
   > 为了支持 JMM，Java 定义了8种原子操作，用来控制主存与工作内存之间的交互：
   - read 读取：作用于主内存，将共享变量从主内存传送到线程的工作内存中。
   - load 载入：作用于工作内存，把 read 读取的值放到工作内存中的副本变量中
   - store 存储：作用于工作内存，把工作内存中的变量传送到主内存中。
   - write 写入：作用于主内存，把从工作内存中 store 传送过来的值写到主内存的变量中。
   - use 使用：作用于工作内存，把工作内存的值传递给执行引擎，当虚拟机遇到一个需要使用这个变量的指令时，就会执行这个动作。
   - assign 赋值：作用于工作内存，把执行引擎获取到的值赋值给工作内存中的变量，当虚拟机栈遇到给变量赋值的指令时，就执行此操作。
   - lock锁定： 作用于主内存，把变量标记为线程独占状态。
   - unlock解锁： 作用于主内存，它将释放独占状态。

---
# 参考资料
  - [JMM（Java内存模型）详解](https://blog.csdn.net/LYQ20010417/article/details/124138635)
  - [面试官为什么总是问happens-before规则，看完这篇文章你就懂了](https://baijiahao.baidu.com/s?id=1654963077694559106)

---
- [回到首页](../../README.md)